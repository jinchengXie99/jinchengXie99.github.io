<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux系统编程-第03天（makefile-文件IO） | Jincのblog</title><meta name="keywords" content="Linux系统编程"><meta name="author" content="Jincheng Xie"><meta name="copyright" content="Jincheng Xie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文件IO常用函数、文件读写原理、进程控制块概念、阻塞、非阻塞概念">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程-第03天（makefile-文件IO）">
<meta property="og:url" content="https://jinchengxie99.github.io/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/index.html">
<meta property="og:site_name" content="Jincのblog">
<meta property="og:description" content="文件IO常用函数、文件读写原理、进程控制块概念、阻塞、非阻塞概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=3424568019,2040822130&fm=253&fmt=auto&app=138&f=PNG?w=500&h=300">
<meta property="article:published_time" content="2022-05-01T15:36:31.000Z">
<meta property="article:modified_time" content="2022-05-10T03:27:52.796Z">
<meta property="article:author" content="Jincheng Xie">
<meta property="article:tag" content="Linux系统编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=3424568019,2040822130&fm=253&fmt=auto&app=138&f=PNG?w=500&h=300"><link rel="shortcut icon" href="https://down.556z.com/upload/2020/12/202012141607934528737148.jpg"><link rel="canonical" href="https://jinchengxie99.github.io/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":75,"languages":{"author":"作者: Jincheng Xie","link":"链接: ","source":"来源: Jincのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux系统编程-第03天（makefile-文件IO）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-10 11:27:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://down.556z.com/upload/2020/12/202012141607934528737148.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jincのblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux系统编程-第03天（makefile-文件IO）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-01T15:36:31.000Z" title="发表于 2022-05-01 23:36:31">2022-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-10T03:27:52.796Z" title="更新于 2022-05-10 11:27:52">2022-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux系统编程-第03天（makefile-文件IO）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="01-学习目标"><a href="#01-学习目标" class="headerlink" title="01. 学习目标"></a>01. 学习目标</h2><ul>
<li>熟练掌握Linux下的静态库的制作</li>
<li>熟练掌握Linux下的静态库的使用</li>
<li>熟练掌握Linux下的共享库的制作</li>
<li>熟练掌握Linux下的共享库的使用</li>
<li>独立解决动态库加载失败的问题</li>
<li>熟练使用规则编写简单的makefile文件</li>
<li>熟练使用makefile中的变量</li>
<li>熟练使用makefile中的函数</li>
<li>熟练掌握gdb相关调试命令的使用</li>
</ul>
<h2 id="02-Makefile简介"><a href="#02-Makefile简介" class="headerlink" title="02. Makefile简介"></a>02. Makefile简介</h2><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Shell%E8%84%9A%E6%9C%AC">Shell脚本</a>一样，其中也可以执行操作系统的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4/8135974">命令</a>。</p>
<p>Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IDE">IDE</a>都有这个命令，比如：Delphi的make，[Visual C++](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Visual">https://baike.baidu.com/item/Visual</a> C%2B%2B)的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<p><strong>make主要解决两个问题：</strong></p>
<p><strong>1) 大量代码的关系维护</strong></p>
<p>大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护</p>
<p>把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译</p>
<p><strong>2) 减少重复编译时间</strong></p>
<p>n 在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间</p>
<p><strong>Makefile文件命名规则</strong></p>
<p>makefile和Makefile都可以，推荐使用Makefile。</p>
<p><strong>make工具的安装</strong></p>
<blockquote>
<p>sudo apt install make</p>
</blockquote>
<h2 id="03-Makefile语法规则"><a href="#03-Makefile语法规则" class="headerlink" title="03. Makefile语法规则"></a>03. Makefile语法规则</h2><p><strong>一条规则：</strong></p>
<blockquote>
<p>目标：依赖文件列表</p>
<p>​		命令列表</p>
</blockquote>
<p>Makefile基本规则三要素：</p>
<p>1）目标：</p>
<ul>
<li>通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个动作的名称</li>
</ul>
<p>2）依赖文件：</p>
<ul>
<li>用来输入从而产生目标的文件</li>
<li>一个目标通常有几个依赖文件（可以没有）</li>
</ul>
<p>3）命令：</p>
<ul>
<li>make执行的动作，一个规则可以含几个命令（可以没有）</li>
<li>有多个命令时，每个命令占一行</li>
</ul>
<p><strong>举例说明：</strong></p>
<p>测试代码：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">    echo <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test1 test2</span></span><br><span class="line">    echo <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">    echo <span class="string">&quot;test1&quot;</span></span><br><span class="line"><span class="section">test2:</span></span><br><span class="line">    echo <span class="string">&quot;test2&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="04-make命令格式"><a href="#04-make命令格式" class="headerlink" title="04. make命令格式"></a>04. make命令格式</h2><p>make是一个命令工具，它解释Makefile 中的指令（应该说是规则）。</p>
<p>make命令格式：</p>
<p>make [ -f file ][ options ][ targets ]</p>
<p>1.[ -f file ]：</p>
<ul>
<li>make默认在工作目录中寻找名为GNUmakefile、makefile、Makefile的文件作为makefile输入文件</li>
<li>-f 可以指定以上名字以外的文件作为makefile输入文件</li>
</ul>
<p>l</p>
<p>2.[ options ]</p>
<ul>
<li>-v： 显示make工具的版本信息</li>
<li>-w： 在处理makefile之前和之后显示工作路径</li>
<li>-C dir：读取makefile之前改变工作路径至dir目录</li>
<li>-n：只打印要执行的命令但不执行</li>
<li>-s：执行但不显示执行的命令</li>
</ul>
<p>3.[ targets ]：</p>
<ul>
<li>若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出</li>
<li>指定了make工具要实现的目标，目标可以是一个或多个（多个目标间用空格隔开）。</li>
</ul>
<p>示例：</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527734864437.png" alt="1527734864437"></p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527735007592.png" alt="1527735007592"></p>
<h2 id="05-Makefile工作原理"><a href="#05-Makefile工作原理" class="headerlink" title="05. Makefile工作原理"></a>05. Makefile工作原理</h2><p>1）若想生成目标, 检查规则中的依赖条件是否存在,如不存在,则寻找是否有规则用来 生成该依赖文件</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/clip_image002.jpg" alt="img"></p>
<p>2） 检查规则中的目标是否需要更新，必须先检查它的所有依赖,依赖中有任一个被更新,则目标必须更新</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/clip_image002-1527647235911.jpg" alt="img"></p>
<p><strong>总结：</strong></p>
<p>Ø 分析各个目标和依赖之间的关系</p>
<p>Ø 根据依赖关系自底向上执行命令</p>
<p>Ø 根据修改时间比目标新,确定更新</p>
<p>Ø 如果目标不依赖任何条件,则执行对应命令,以示更新</p>
<h2 id="06-Makefile示例"><a href="#06-Makefile示例" class="headerlink" title="06. Makefile示例"></a>06. Makefile示例</h2><p>测试程序： test.c add.c sub.c mul.c div.c</p>
<p><strong>6.1 最简单的Makefile</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:test.c add.c sub.c mul.c div.c</span><br><span class="line">gcc test.c add.c sub.c mul.c div.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>缺点：效率低，修改一个文件，所有文件会被全部编译 </p>
<p><strong>6.2 第二个版本Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o add.o sub.o mul.o div.o</span></span><br><span class="line">    gcc test.o add.o sub.o mul.o div.o -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">    gcc -c test.c</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">    gcc -c add.c</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">    gcc -c sub.c</span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">    gcc -c mul.c</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">    gcc -c div.c</span><br></pre></td></tr></table></figure>



<h2 id="07-Makefile中的变量"><a href="#07-Makefile中的变量" class="headerlink" title="07. Makefile中的变量"></a>07. Makefile中的变量</h2><p>在Makefile中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护,修改内容变得简单变量定义及使用。</p>
<p><strong>7.1 自定义变量</strong></p>
<p>1）定义变量方法：</p>
<p>变量名&#x3D;变量值</p>
<p>2）引用变量：</p>
<p>$(变量名)或${变量名}</p>
<p>3）makefile的变量名：</p>
<ul>
<li>makefile变量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在makefile的头部定义</li>
<li>变量几乎可在makefile的任何地方使用</li>
</ul>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量</span></span><br><span class="line">OBJS=add.o sub.o mul.o div.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">    gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">    gcc -c sub.c -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">    gcc -c mul.c -o mul.o</span><br><span class="line"></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">    gcc -c div.c -o div.o</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">    gcc -c test.c -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>



<p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。</p>
<blockquote>
<p>CC &#x3D; gcc #arm-linux-gcc</p>
<p>CPPFLAGS : C预处理的选项 如:-I</p>
<p>CFLAGS: C编译器的选项 -Wall -g -c</p>
<p>LDFLAGS : 链接器选项 -L -l</p>
</blockquote>
<p><strong>7.2 自动变量</strong></p>
<ul>
<li>$@: 表示规则中的目标</li>
<li>$&lt;: 表示规则中的第一个条件</li>
<li>$^: 表示规则中的所有条件, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</li>
</ul>
<p><strong>注意：自动变量只能在规则的命令中中使用</strong></p>
<p>参考示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#变量</span></span><br><span class="line">OBJS=add.o sub.o mul.o div.o test.o add.o</span><br><span class="line">TARGET=test</span><br><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line"><span class="comment">#$@: 表示目标</span></span><br><span class="line"><span class="comment">#$&lt;: 表示第一个依赖</span></span><br><span class="line"><span class="comment">#$^: 表示所有的依赖</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="comment">#$(CC) $(OBJS) -o $(TARGET) </span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">    echo <span class="variable">$@</span></span><br><span class="line">    echo <span class="variable">$&lt;</span></span><br><span class="line">    echo <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>



<p><strong>7.3 模式规则</strong></p>
<p>模式规则示例:</p>
<blockquote>
<p>%.o:%.c</p>
<p>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p>
</blockquote>
<p>Makefile第三个版本：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    OBJS=test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="08-Makefile中的函数"><a href="#08-Makefile中的函数" class="headerlink" title="08. Makefile中的函数"></a>08. Makefile中的函数</h2><p>makefile中的函数有很多，在这里给大家介绍两个最常用的。</p>
<blockquote>
<ol>
<li>wildcard – 查找指定目录下的指定类型的文件</li>
</ol>
<p>src &#x3D; $(wildcard *.c) &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件,赋值给src</p>
<ol>
<li>patsubst – 匹配替换</li>
</ol>
<p>obj &#x3D; $(patsubst %.c,%.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
</blockquote>
<p>在makefile中所有的函数都是有返回值的。</p>
<p>Makefile第四个版本：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br></pre></td></tr></table></figure>

<h2 id="09-Makefile中的伪目标"><a href="#09-Makefile中的伪目标" class="headerlink" title="09. Makefile中的伪目标"></a>09. Makefile中的伪目标</h2><p>clean用途: 清除编译生成的中间.o文件和最终目标文件</p>
<p>make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p>
<p>Ø <strong>伪目标声明:</strong> <strong>.PHONY:clean</strong></p>
<p>声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新</p>
<p><strong>clean命令中的特殊符号：</strong></p>
<ul>
<li>“-”此条命令出错，make也会继续执行后续的命令。如:“-rm main.o”</li>
<li>“@”不显示命令本身,只显示结果。如:“@echo clean done”</li>
</ul>
<p>Makefile第五个版本：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span> </span><br></pre></td></tr></table></figure>

<p>总结： 一条规则，两个函数，三个变量。</p>
<h2 id="10-系统调用简介和实现"><a href="#10-系统调用简介和实现" class="headerlink" title="10. 系统调用简介和实现"></a>10. 系统调用简介和实现</h2><p><strong>10.1 什么是系统调用</strong></p>
<p>系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。</p>
<p>从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527649958892.png" alt="1527649958892"></p>
<p>系统服务之所以需要通过系统调用来提供给用户空间的根本原因是为了对系统进行“保护”，因为我们知道 Linux 的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。</p>
<p>所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间函数。</p>
<p>比如我们熟悉的“hello world”程序（执行时）就是标准的用户空间进程，它使用的打印函数 printf 就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。</p>
<p>但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊接口”——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置。</p>
<p>换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无误。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实地坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。</p>
<p><strong>10.2 系统调用的实现</strong></p>
<p>系统调用是属于操作系统内核的一部分的，必须以某种方式提供给进程让它们去调用。CPU 可以在不同的特权级别下运行，而相应的操作系统也有不同的运行级别，<strong>用户态和内核态</strong>。运行在内核态的进程可以毫无限制的访问各种资源，而在用户态下的用户进程的各种操作都有着限制，比如不能随意的访问内存、不能开闭中断以及切换运行的特权级别。显然，属于内核的系统调用一定是运行在内核态下，但是如何切换到内核态呢？</p>
<p>答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。<strong>操作系统一般是通过软件中断从用户态切换到内核态。</strong></p>
<h2 id="11-系统调用和库函数的区别"><a href="#11-系统调用和库函数的区别" class="headerlink" title="11. 系统调用和库函数的区别"></a>11. 系统调用和库函数的区别</h2><p>Linux 下对文件操作有两种方式：<strong>系统调用（system call）</strong>和<strong>库函数调用（Library functions）</strong>。</p>
<p>库函数由两类函数组成：</p>
<p>1）不需要调用系统调用</p>
<p>不需要切换到内核空间即可完成函数全部功能，并且将结果反馈给应用程序，如strcpy、bzero 等字符串操作函数。</p>
<p>2）需要调用系统调用</p>
<p>需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如 printf、fread等。</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527650321383.png" alt="1527650321383"></p>
<p>系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗掉许多时间 。</p>
<h2 id="12-C库中IO函数工作流程"><a href="#12-C库中IO函数工作流程" class="headerlink" title="12. C库中IO函数工作流程"></a>12. C库中IO函数工作流程</h2><p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527650554264.png" alt="1527650554264"></p>
<p>库函数访问文件的时候根据需要，设置不同类型的缓冲区，从而减少了直接调用 IO 系统调用的次数，提高了访问效率。</p>
<p>这个过程类似于快递员给某个区域（内核空间）送快递一样，快递员有两种方式送：</p>
<p>1）来一件快递就马上送到目的地，来一件送一件，这样导致来回走比较频繁（系统调用）</p>
<p>2）等快递攒着差不多后（缓冲区），才一次性送到目的地（库函数调用）</p>
<h2 id="13-错误处理函数"><a href="#13-错误处理函数" class="headerlink" title="13. 错误处理函数"></a>13. 错误处理函数</h2><p>errno 是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p>
<p>当Linux C api函数发生异常时，一般会将errno全局变量赋一个整数值，不同的值表示不同的含义，可以通过查看该值推测出错的原因。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//fopen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  <span class="comment">//errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//strerror(errno)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;xxxx&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, errno);  <span class="comment">//打印错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno)); <span class="comment">//把errno的数字转换成相应的文字</span></span><br><span class="line">        perror(<span class="string">&quot;fopen err&quot;</span>);    <span class="comment">//打印错误原因的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>查看错误号：</p>
<blockquote>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h</p>
</blockquote>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527755557333.png" alt="1527755557333"></p>
<h2 id="14-虚拟地址空间"><a href="#14-虚拟地址空间" class="headerlink" title="14. 虚拟地址空间"></a>14. 虚拟地址空间</h2><p>每个进程都会分配虚拟地址空间，在32位机器上，该地址空间为4G 。</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527650975663.png" alt="1527650975663"></p>
<p>在进程里平时所说的指针变量，保存的就是虚拟地址。当应用程序使用虚拟地址访问内存时，处理器（CPU）会将其转化成物理地址（MMU）。</p>
<p>MMU：将虚拟的地址转化为物理地址。</p>
<p>这样做的好处在于：</p>
<ul>
<li>进程隔离，更好的保护系统安全运行</li>
<li>屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址</li>
</ul>
<h2 id="15-文件描述符"><a href="#15-文件描述符" class="headerlink" title="15. 文件描述符"></a>15. 文件描述符</h2><p>在 Linux 的世界里，一切设备皆文件。我们可以系统调用中 I&#x2F;O 的函数（I：input，输入；O：output，输出），对文件进行相应的操作（ open()、close()、write() 、read() 等）。</p>
<p>打开现存文件或新建文件时，系统（内核）会返回一个文件描述符，文件描述符用来指定已打开的文件。这个文件描述符相当于这个已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符 0、1、2 记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO  0 <span class="comment">//标准输入的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1 <span class="comment">//标准输出的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2 <span class="comment">//标准错误的文件描述符</span></span></span><br></pre></td></tr></table></figure>

<p>在程序运行起来后打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527651181126.png" alt="1527651181126"></p>
<p><strong>最大打开的文件个数</strong></p>
<p>Linux 中一个进程最多只能打开 NR_OPEN_DEFAULT （即1024）个文件，故当文件不再使用时应及时调用 close() 函数关闭文件。</p>
<ul>
<li><p>查看当前系统允许打开最大文件个数：</p>
<blockquote>
<p>cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
</blockquote>
</li>
<li><p>当前默认设置最大打开文件个数1024</p>
<blockquote>
<p>ulimit -a</p>
</blockquote>
</li>
<li><p>修改默认设置最大打开文件个数为4096</p>
<blockquote>
<p>ulimit -n 4096</p>
</blockquote>
</li>
</ul>
<h2 id="16-常用文件IO函数"><a href="#16-常用文件IO函数" class="headerlink" title="16. 常用文件IO函数"></a>16. 常用文件IO函数</h2><h3 id="16-1-open函数"><a href="#16-1-open函数" class="headerlink" title="16.1 open函数"></a>16.1 open函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：</span><br><span class="line">    打开文件，如果文件不存在则可以选择创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件的路径及文件名</span><br><span class="line">    flags：打开文件的行为标志，必选项 O_RDONLY, O_WRONLY, O_RDWR</span><br><span class="line">    mode：这个参数，只有在文件不存在时有效，指新建文件时指定文件的权限</span><br><span class="line">返回值：</span><br><span class="line">    成功：成功返回打开的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span> </span><br></pre></td></tr></table></figure>

<p><strong>flags详细说明</strong></p>
<p>必选项：</p>
<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">O_RDONLY</td>
<td align="left">以只读的方式打开</td>
</tr>
<tr>
<td align="left">O_WRONLY</td>
<td align="left">以只写的方式打开</td>
</tr>
<tr>
<td align="left">O_RDWR</td>
<td align="left">以可读、可写的方式打开</td>
</tr>
</tbody></table>
<p>可选项，和必选项按位或起来</p>
<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">O_CREAT</td>
<td align="left">文件不存在则创建文件，使用此选项时需使用mode说明文件的权限</td>
</tr>
<tr>
<td align="left">O_EXCL</td>
<td align="left">如果同时指定了O_CREAT，且文件已经存在，则出错</td>
</tr>
<tr>
<td align="left">O_TRUNC</td>
<td align="left">如果文件存在，则清空文件内容</td>
</tr>
<tr>
<td align="left">O_APPEND</td>
<td align="left">写文件时，数据添加到文件末尾</td>
</tr>
<tr>
<td align="left">O_NONBLOCK</td>
<td align="left">对于设备文件, 以O_NONBLOCK方式打开可以做非阻塞I&#x2F;O</td>
</tr>
</tbody></table>
<p><strong>mode补充说明</strong></p>
<p>\1) 文件最终权限：mode &amp; ~umask</p>
<p>\2) shell进程的umask掩码可以用umask命令查看</p>
<p>Ø umask：查看掩码（补码）</p>
<p>Ø umask mode：设置掩码，mode为八进制数</p>
<p>Ø umask -S：查看各组用户的默认操作权限</p>
<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>八进制</strong></th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S_IRWXU</td>
<td align="left">00700</td>
<td align="left">文件所有者的读、写、可执行权限</td>
</tr>
<tr>
<td align="left">S_IRUSR</td>
<td align="left">00400</td>
<td align="left">文件所有者的读权限</td>
</tr>
<tr>
<td align="left">S_IWUSR</td>
<td align="left">00200</td>
<td align="left">文件所有者的写权限</td>
</tr>
<tr>
<td align="left">S_IXUSR</td>
<td align="left">00100</td>
<td align="left">文件所有者的可执行权限</td>
</tr>
<tr>
<td align="left">S_IRWXG</td>
<td align="left">00070</td>
<td align="left">文件所有者同组用户的读、写、可执行权限</td>
</tr>
<tr>
<td align="left">S_IRGRP</td>
<td align="left">00040</td>
<td align="left">文件所有者同组用户的读权限</td>
</tr>
<tr>
<td align="left">S_IWGRP</td>
<td align="left">00020</td>
<td align="left">文件所有者同组用户的写权限</td>
</tr>
<tr>
<td align="left">S_IXGRP</td>
<td align="left">00010</td>
<td align="left">文件所有者同组用户的可执行权限</td>
</tr>
<tr>
<td align="left">S_IRWXO</td>
<td align="left">00007</td>
<td align="left">其他组用户的读、写、可执行权限</td>
</tr>
<tr>
<td align="left">S_IROTH</td>
<td align="left">00004</td>
<td align="left">其他组用户的读权限</td>
</tr>
<tr>
<td align="left">S_IWOTH</td>
<td align="left">00002</td>
<td align="left">其他组用户的写权限</td>
</tr>
<tr>
<td align="left">S_IXOTH</td>
<td align="left">00001</td>
<td align="left">其他组用户的可执行权限</td>
</tr>
</tbody></table>
<h3 id="16-2-close函数"><a href="#16-2-close函数" class="headerlink" title="16.2 close函数"></a>16.2 close函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">    fd : 文件描述符，open()的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： <span class="number">-1</span>, 并设置errno</span><br></pre></td></tr></table></figure>

<p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。</p>
<p>但是对于一个长年累月运行的程序(比如网络服务器)，打开的文件描述符一定要记得关闭,否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</p>
<h3 id="16-3-write函数"><a href="#16-3-write函数" class="headerlink" title="16.3 write函数"></a>16.3 write函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd :  文件描述符</span><br><span class="line">    buf : 数据首地址</span><br><span class="line">    count : 写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="16-4-read函数"><a href="#16-4-read函数" class="headerlink" title="16.4 read函数"></a>16.4 read函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据读到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd : 文件描述符</span><br><span class="line">    buf : 内存首地址</span><br><span class="line">    count : 读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取到的字节个数</span><br><span class="line">    失败： - <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p><strong>阻塞和非阻塞的概念</strong></p>
<p>读常规文件是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回。</p>
<p>从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p>
<p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p>
<p>【注意】阻塞与非阻塞是对于文件而言的，而不是指read、write等的属性。</p>
<p>以非阻塞方式打开文件程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//read</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">//EAGAIN</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// /dev/tty --&gt; 当前终端设备</span></span><br><span class="line">    <span class="comment">// 以不阻塞方式(O_NONBLOCK)打开终端设备</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果为非阻塞，但是没有数据可读，此时全局变量 errno 被设置为 EAGAIN</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有数据\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-5-lseek函数"><a href="#16-5-lseek函数" class="headerlink" title="16.5 lseek函数"></a>16.5 lseek函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">功能：</span><br><span class="line">    改变文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line"></span><br><span class="line">    whence：其取值如下：</span><br><span class="line">        SEEK_SET：从文件开头移动offset个字节</span><br><span class="line">        SEEK_CUR：从当前位置移动offset个字节</span><br><span class="line">        SEEK_END：从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">    若lseek成功执行, 则返回新的偏移量</span><br><span class="line">    如果失败， 返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>所有打开的文件都有一个当前文件偏移量(current file offset)，以下简称为 cfo。cfo 通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。</p>
<p>读写操作通常开始于 cfo，并且使 cfo 增大，增量为读写的字节数。文件被打开时，cfo 会被初始化为 0，除非使用了 O_APPEND 。</p>
<h2 id="17-扩展-ctags使用"><a href="#17-扩展-ctags使用" class="headerlink" title="17. 扩展-ctags使用"></a>17. 扩展-ctags使用</h2><p>第一步： 安装ctags</p>
<blockquote>
<p>deng@itcast:~&#x2F;linux-4.16.12$ sudo apt install exuberant-ctags</p>
</blockquote>
<p>第二步：&#x2F;usr&#x2F;include中生成tags文件</p>
<blockquote>
<p>切换到&#x2F;usr&#x2F;include</p>
<p>deng@itcast:&#x2F;usr&#x2F;include$ pwd &#x2F;usr&#x2F;include</p>
<p>生成ctags文件</p>
<p>deng@itcast:&#x2F;usr&#x2F;include的密码： ls -l tags </p>
<p>-rw-r–r– 1 root root 5271877 5月 31 13:00 tags </p>
<p>deng@itcast:&#x2F;usr&#x2F;include$</p>
</blockquote>
<p>第二个tags</p>
<blockquote>
<p>deng@itcast:&#x2F;usr&#x2F;src&#x2F;linux-headers-4.10.0-28 sudo ctags -Rn .</p>
</blockquote>
<p>第三步: 配置vimrc</p>
<p>在~&#x2F;.vimrc文件中最后一行添加如下内容：</p>
<blockquote>
<p>set tags+&#x3D;&#x2F;usr&#x2F;include&#x2F;tags</p>
<p>set tags+&#x3D;&#x2F;usr&#x2F;src&#x2F;linux-headers-4.10.0-28&#x2F;tags</p>
</blockquote>
<p>第四步： 生效vimrc</p>
<p>执行如下命令</p>
<blockquote>
<p>deng@itcast:~&#x2F;linux-4.16.12$ source ~&#x2F;.vimrc</p>
</blockquote>
<p>Ctrl + ] 表示跟踪代码</p>
<p>Ctrl + t 表示回去</p>
<blockquote>
<p>deng@itcast:~$ vim -t STDIN_FILENO</p>
</blockquote>
<h2 id="18-作业"><a href="#18-作业" class="headerlink" title="18. 作业"></a>18. 作业</h2><p><strong>1） 有两个互不相干的文件a.c和b.c，编写Makefile之后，make生成可执行文件a和b。</strong></p>
<blockquote>
<p>deng@itcast:~&#x2F;share&#x2F;3rd&#x2F;homework&#x2F;2makefile$ ls a.c b.c Makefile </p>
<p>deng@itcast:~&#x2F;share&#x2F;3rd&#x2F;homework&#x2F;2makefile$ make </p>
<p>deng@itcast:~&#x2F;share&#x2F;3rd&#x2F;homework&#x2F;2makefile$ ls a a.c a.o b b.c b.o Makefile </p>
<p>deng@itcast:~&#x2F;share&#x2F;3rd&#x2F;homework&#x2F;2makefile$ .&#x2F;a hello a </p>
<p>deng@itcast:~&#x2F;share&#x2F;3rd&#x2F;homework&#x2F;2makefile$ .&#x2F;b hello b</p>
</blockquote>
<p><strong>2) 在1makefile中有如下目录， 编写Makefile生成可执行文件test</strong></p>
<p>源文件如下：</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527855879183.png" alt="1527855879183"></p>
<p>要求：生成的目标文件存储在obj目录中， 生成的可执行文件test存储在bin目录中。</p>
<p>执行结果如下：</p>
<p><img src="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1527856217244.png" alt="1527856217244"></p>
<p><strong>3）使用read和write实现文件拷贝。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jinchengXie99.github.io">Jincheng Xie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinchengxie99.github.io/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/">https://jinchengxie99.github.io/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinchengXie99.github.io" target="_blank">Jincのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC04%E5%A4%A9%EF%BC%88%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%89/"><img class="prev-cover" src="https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux系统编程-第04天（文件和目录操作函数）</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC02%E5%A4%A9%EF%BC%88vim-gcc-%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%89/"><img class="next-cover" src="https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux系统编程-第02天（vim-gcc-动态库静态库）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC02%E5%A4%A9%EF%BC%88vim-gcc-%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%89/" title="Linux系统编程-第02天（vim-gcc-动态库静态库）"><img class="cover" src="https://img1.baidu.com/it/u=3424568019,2040822130&fm=253&fmt=auto&app=138&f=PNG?w=500&h=300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">Linux系统编程-第02天（vim-gcc-动态库静态库）</div></div></a></div><div><a href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC04%E5%A4%A9%EF%BC%88%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%89/" title="Linux系统编程-第04天（文件和目录操作函数）"><img class="cover" src="https://img1.baidu.com/it/u=3424568019,2040822130&fm=253&fmt=auto&app=138&f=PNG?w=500&h=300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-02</div><div class="title">Linux系统编程-第04天（文件和目录操作函数）</div></div></a></div><div><a href="/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC01%E5%A4%A9%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%89/" title="Linux系统编程-第01天（基本命令）"><img class="cover" src="https://img1.baidu.com/it/u=3424568019,2040822130&fm=253&fmt=auto&app=138&f=PNG?w=500&h=300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-29</div><div class="title">Linux系统编程-第01天（基本命令）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://down.556z.com/upload/2020/12/202012141607934528737148.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jincheng Xie</div><div class="author-info__description">锅不仅可以烧饭,而且可以写代码.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jinchengXie99"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jinchengXie99" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:chengdiy@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog.  很高兴你能来到我的博客。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.</span> <span class="toc-text">01. 学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Makefile%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">02. Makefile简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-Makefile%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">03. Makefile语法规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-make%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">04. make命令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">05. Makefile工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-Makefile%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">06. Makefile示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-Makefile%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">7.</span> <span class="toc-text">07. Makefile中的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-Makefile%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">08. Makefile中的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-Makefile%E4%B8%AD%E7%9A%84%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-number">9.</span> <span class="toc-text">09. Makefile中的伪目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.</span> <span class="toc-text">10. 系统调用简介和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">11. 系统调用和库函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-C%E5%BA%93%E4%B8%ADIO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">12. C库中IO函数工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">13. 错误处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">14.</span> <span class="toc-text">14. 虚拟地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">15.</span> <span class="toc-text">15. 文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6IO%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">16. 常用文件IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-open%E5%87%BD%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">16.1 open函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-close%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.</span> <span class="toc-text">16.2 close函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-write%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.</span> <span class="toc-text">16.3 write函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-read%E5%87%BD%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">16.4 read函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-lseek%E5%87%BD%E6%95%B0"><span class="toc-number">16.5.</span> <span class="toc-text">16.5 lseek函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%89%A9%E5%B1%95-ctags%E4%BD%BF%E7%94%A8"><span class="toc-number">17.</span> <span class="toc-text">17. 扩展-ctags使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BD%9C%E4%B8%9A"><span class="toc-number">18.</span> <span class="toc-text">18. 作业</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC04%E5%A4%A9%EF%BC%88%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%89/" title="Linux系统编程-第04天（文件和目录操作函数）"><img src="https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-第04天（文件和目录操作函数）"/></a><div class="content"><a class="title" href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC04%E5%A4%A9%EF%BC%88%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%89/" title="Linux系统编程-第04天（文件和目录操作函数）">Linux系统编程-第04天（文件和目录操作函数）</a><time datetime="2022-05-02T04:49:23.000Z" title="发表于 2022-05-02 12:49:23">2022-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/" title="Linux系统编程-第03天（makefile-文件IO）"><img src="https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-第03天（makefile-文件IO）"/></a><div class="content"><a class="title" href="/2022/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/" title="Linux系统编程-第03天（makefile-文件IO）">Linux系统编程-第03天（makefile-文件IO）</a><time datetime="2022-05-01T15:36:31.000Z" title="发表于 2022-05-01 23:36:31">2022-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC02%E5%A4%A9%EF%BC%88vim-gcc-%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%89/" title="Linux系统编程-第02天（vim-gcc-动态库静态库）"><img src="https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-第02天（vim-gcc-动态库静态库）"/></a><div class="content"><a class="title" href="/2022/04/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC02%E5%A4%A9%EF%BC%88vim-gcc-%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%89/" title="Linux系统编程-第02天（vim-gcc-动态库静态库）">Linux系统编程-第02天（vim-gcc-动态库静态库）</a><time datetime="2022-04-30T15:19:35.000Z" title="发表于 2022-04-30 23:19:35">2022-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC01%E5%A4%A9%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%89/" title="Linux系统编程-第01天（基本命令）"><img src="https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-第01天（基本命令）"/></a><div class="content"><a class="title" href="/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC01%E5%A4%A9%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%89/" title="Linux系统编程-第01天（基本命令）">Linux系统编程-第01天（基本命令）</a><time datetime="2022-04-29T15:13:15.000Z" title="发表于 2022-04-29 23:13:15">2022-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C-%E9%9A%8F%E7%AC%94/" title="深入应用C++11:note"><img src="https://img1.baidu.com/it/u=3758033088,2640479584&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=820&amp;h=461" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入应用C++11:note"/></a><div class="content"><a class="title" href="/2022/04/19/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C-%E9%9A%8F%E7%AC%94/" title="深入应用C++11:note">深入应用C++11:note</a><time datetime="2022-04-19T15:46:09.000Z" title="发表于 2022-04-19 23:46:09">2022-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img1.baidu.com/it/u=3424568019,2040822130&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=300')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jincheng Xie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">哟！屏幕前有个大帅逼。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>